---
title: "Nettoyage et enrichissement des données HAL"
subtitle: "Désambiguïsation des intitulés de conférences"
output:
  html_document:
    self_contained: false
    theme: paper
    toc: yes
    toc_float: yes
    includes:
      in_header: header.html
      after_body: footer.html
      
knit: (
  function(inputFile, encoding) { 
    
    rmarkdown::render(inputFile, params = "ask",  
      encoding    = encoding,
      output_file = paste0(tools::file_path_sans_ext(inputFile), ".html")) })
---

<style>
body {
text-align: justify;
#background: #f9f9f9;
}
</style> 

```{r setup, include=FALSE}
# Settings summarytools
library(summarytools)
st_options(plain.ascii = FALSE,               # This is very handy in all Rmd documents
           style = "rmarkdown",               # This too
           footnote = NA,                    # Avoids footnotes which would clutter the results
           subtitle.emphasis = FALSE
         # This is a setting to experiment with - according to the theme used, it might improve the headings layout
)
# General settings      
knitr::opts_chunk$set(
	eval = TRUE,
	echo = FALSE,
	fig.align = "center",
	fig.show = "hold",
	message = FALSE,
	warning = FALSE,
	collapse = TRUE,
	results = 'asis', # important dfSummary
	out.width = "100%"
)
```


----

```{r librairies et données, include = FALSE}
# Packages nécessaires à l'analyse
packages = c("tidyverse", "summarytools", "threadr", "rvest", "fuzzyjoin")

## Installation des packages si besoin et chargement des librairies
package.check <- lapply(packages,
  FUN = function(x) {
      if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE)  #remotes::install_github("skgrange/threadr")
      library(x, character.only = TRUE)}})


# Import données 

    # HAL (bibTex)
hal1 <- read_bibtex("https://api.archives-ouvertes.fr/search/?q=+publicationDateY_i%3A[2018+TO+2020]+AND++(docType_s%3ACOMM)&fq=collCode_s%3AINRIA2&rows=100000&wt=bibtex")
hal2 <- read_bibtex("https://api.archives-ouvertes.fr/search/?q=+publicationDateY_i%3A[2021+TO+2022]+AND++(docType_s%3ACOMM)&fq=collCode_s%3AINRIA2&rows=100000&wt=bibtex")
hal <- rbind(hal1 %>% select(bibtex_key, article_type, title, author, url, editor, series, volume, number, pages, year, month, keywords, pdf, hal_id, hal_version, publisher, doi, organization, booktitle, address ), 
              hal2 %>% select(bibtex_key, article_type, title, author, url, editor, series, volume, number, pages, year, month, keywords, pdf, hal_id, hal_version, publisher, doi, organization, booktitle, address )) %>% 
    distinct() %>% 
    filter(year >= 2018 & year <= 2022) # 10.052 articles

    # CORE (CSV)
core <- purrr::map(
        .x = (as.data.frame(rep(1:45, each = 1)) %>% rename(page = `rep(1:45, each = 1)`))$page,
        .y = data.frame(matrix(ncol = 1, nrow = 1)),
        .f = ~read_html(paste0("http://portal.core.edu.au/conf-ranks/?search=&by=all&source=all&sort=atitle&page=", .x)) %>% html_nodes('body')  %>% html_nodes('table') %>% html_table(dec = ","), 
        .default = NA)
core <- bind_rows(core) %>% rename(title = Title) %>% 
    mutate_all(na_if,"") %>% 
    mutate(core_id = row_number()) # 2.212 conférences
```


**Objectif** : Désambiguïsation des intitulés de conférences renseignés dans les données du HAL, en se basant sur le référentiel CORE

**Données à nettoyer** : 

- **Sources des données** : [API Archive Ouverte HAL]()
- **Dimensions** : `r ncol(hal)` variables et `r nrow(hal)` observations

**Données références** : 

- **Sources des données** : [Portail CORE]()
- **Dimensions** : `r ncol(core)` variables et `r nrow(core)` observations


---

# Résumé des bases{.tabset}

## HAL

```{r}
dfSummary(hal, style = "grid", graph.magnif = 1, valid.col = FALSE, varnumbers = FALSE, tmp.img.dir = "/tmp", max.distinct.values = 5, headings=FALSE, method = "render")
```

<br>

## CORE

```{r}
dfSummary(core, style = "grid", graph.magnif = 1, valid.col = FALSE, varnumbers = FALSE, tmp.img.dir = "/tmp", max.distinct.values = 5, headings=FALSE, method = "render")
```

<br>

---

# Jointure des bases

<br>

```{r}
# Nettoyage des données
    # HAL
hal_manip <- as.data.frame(gsub("[[:punct:]]", "", as.matrix(hal))) %>%  # retrait de tous les caractères spéciaux
    mutate(hal_title = tolower(title), # minuscules
           hal_title = str_replace(hal_title, "  ", " "), # retrait des doubles espaces
           booktitle = tolower(booktitle), 
           booktitle = str_replace(booktitle, "  ", " "))
    # CORE
core_manip <- as.data.frame(gsub("[[:punct:]]", "", as.matrix(core))) %>%  # retrait de tous les caractères spéciaux
    mutate(core_title = tolower(title), # minuscules
           core_title = str_replace(core_title, "  ", " "), # retrait des doubles espaces
           core_acronym = tolower(Acronym), # même chose pour l'acronyme qui servira de colonne de jointure dans un second temps
           core_acronym = str_replace(core_acronym, "  ", " "),
           nb_car_acronym = str_count(Acronym, '\\w+'))
```


Afin de maximiser le match des conférences, un travail de nettoyage est préalablement exécuté. Les intitulés sont ainsi mis en minuscules, sans accents et sans caractères spéciaux. Un match est opéré 4 fois pour faire correspondre les intitulés des données du HAL avec ceux du référentiel CORE. 

Dans un premier temps ce sont tous les caractères des titres d'articles ou de conférences HAL qui sont matchés avec ceux du CORE, à partir de quoi on obtient une distance correspondant au nombre de caractères **qui ne sont pas communs** au 2 intitulés (si l'intitulé est exactement le même, la distance sera dont de 0). Cette manipulation est réalisée sur les 2 colonnes qui donnent une information sur le titre de conférence dans les données du HAL : *title* et *booktitle*, tous deux matchés avec l'unique champ des données CORE indiquant le nom de conférence ; *title*.

Dans un deuxième temps ce sont tous les mots composant les titres d'articles ou de conférences HAL qui sont matchés avec l'acronyme disponible dans CORE. La jointure se fait cette fois sur une base de match **exact**, contrairement aux manipulations réalisées en premier temps sur les intitulés d'articles et de conférences. Ainsi, lorsqu'un mot du titre disponible dans les données HAL correspond à l'acronyme CORE, les informations du référentiel sont récupérées et viennent enrichir les données HAL. Ici encore la manipulation est réalisée sur les variables HAL *title* et *booktitle*, toutes deux matchées avec l'unique champ des données CORE indiquant l'acronyme de la conférence ; *Acronym*.

<br>

## Match par distance entre les chaînes de caractères (score)

<br>

La première jointure est réalisée en plafonnant la distance d'écart entre les 2 chaînes de caractères, à 50 caractères. 
Pour chaque article HAL, plusieurs conférences sont matchées avec un score de distance allant de 0 à 50. Les données sont ensuite regroupées par article (*hal_id*), puis, seule la conférence ayant le nom le plus proche de celui renseigné dans les données HAL, est gardée. Dans le cas où 2 noms de conférences ont la même distance par rapport au nom HAL et que celle-ci est la distance minimale, les 2 conférences sont gardées dans les données enrichies, et devront alors faire l'objet d'un traitement manuel.
Ce filtre pour ne garder que les conférences CORE dont le nom s'approche le plus des données HAL, est effectué 3 fois ; sur les données HAL enrichies par CORE via le champ *title*, sur les données HAL enrichies par CORE via le champ *booktitle* et sur les données de ces 2 matchs regroupées. Ainsi, pour un même article enrichi via *title* et via *booktitle*, seule la conférence la plus proche du nom CORE est gardée. Pour finir, les intitulés originaux des articles et conférences des 2 sources de données sont réintégrés dans les données, et non plus les intitulés sans caractères spéciaux et en minuscules.

<br>

```{r}
# Match inexacte avec distance
    # colonne de jointure : TITLE
enriched_title <- stringdist_left_join(hal_manip %>% select(hal_title, year, hal_id, booktitle) %>% filter(!is.na(hal_title)),
                                    core_manip %>% select(core_title, Acronym, core_id, Source, Rank, `Primary FoR`),
                                    by = c("hal_title" = "core_title"),
                                    max_dist = 50, 
                                    distance_col = "distance") %>% 
    mutate(colHAL_jointure = "title") %>% 
    arrange(distance) %>% 
    group_by(hal_id) %>% 
    slice_min(order_by = distance, n = 1) # ne garder que le match le plus proche #rename(Acronym_title = Acronym, Source_title = Source, Rank_title = Rank, FoR_title = `Primary FoR`)
    # colonne de jointure : BOOKTITLE
enriched_booktitle <- stringdist_left_join(hal_manip %>% select(hal_title, year, hal_id, booktitle) %>% filter(!is.na(booktitle)),
                                    core_manip %>% select(core_title, Acronym, core_id, Source, Rank, `Primary FoR`),
                                    by = c("booktitle" = "core_title"),
                                    max_dist = 50, 
                                    distance_col = "distance") %>% 
    mutate(colHAL_jointure = "booktitle") %>% 
    arrange(distance) %>% 
    group_by(hal_id) %>% 
    slice_min(order_by = distance, n = 1) # ne garder que le match le plus proche
    # on remet les 2 jointures ensemble
enriched_hal_score <- rbind(enriched_title, enriched_booktitle) %>% 
    group_by(hal_id) %>% slice_min(order_by = distance, n = 1) %>% # ne garder que le match le plus proche entre title et booktitle
    mutate(method = "score")

# On remet les noms initiaux (avec caractères spéciaux et majuscules)
enriched_hal_score <- enriched_hal_score %>% 
    # Noms des articles et conférences dans HAL
    select(-c(hal_title, booktitle)) %>% 
    left_join(., hal %>% select(title, booktitle, hal_id) %>% mutate(hal_id = str_replace_all(hal_id, "-", "")), by = "hal_id") %>% 
    rename(hal_title = title) %>% 
    # Noms des conférences et acronymes dans CORE
    select(-c(core_title)) %>% mutate(core_id = as.numeric(core_id)) %>% 
    left_join(., core %>% select(title, core_id), by = "core_id") %>% 
    rename(core_title = title) %>% 
    # Mise en forme finale
    select("hal_title","year","hal_id","booktitle","core_title","Acronym","Source","Rank","Primary FoR","distance","colHAL_jointure","method")

# Stats sur le nombre de matchs exacts
table <- enriched_hal_score %>% filter(distance == 0) %>% group_by(colHAL_jointure) %>% summarise(n = n())
```



```{r echo=FALSE, warning=FALSE, error=FALSE}
DT::datatable(enriched_hal_score, options=list(pageLength=25, searching=T, scrollX='400px'))
```

Cette première passe de jointure inexacte sur les intitulés de conférences a permis d'enrichir `r n_distinct(enriched_hal_score$hal_id)` articles du HAL sur `r nrow(hal)` entrées, soit `r round(n_distinct(enriched_hal_score$hal_id) / nrow(hal) *100, 0)`%. Parmi ces jointures, `r enriched_hal_score %>% filter(distance == 0) %>% nrow()` sont exactes, c'est-à-dire que l'intitulé dans les données HAL correspond **exactement** à celui de la conférence dans les données CORE (en ayant retiré les caractères spéciaux et les majuscules). Ces dernières ont toutes été faites via le champ *booktitle* des données HAL. Pour les `r n_distinct(enriched_hal_score$hal_id) - enriched_hal_score %>% filter(distance == 0) %>% nrow()` articles restants dont la jointure avec les données CORE est inexacte, le match le plus proche (distance minimisée) provient à `r round(enriched_hal_score %>% distinct(hal_id, colHAL_jointure) %>% group_by(hal_id) %>% mutate(n=n()) %>% filter(n==1, colHAL_jointure == "title") %>% distinct(hal_id) %>% nrow() / (n_distinct(enriched_hal_score$hal_id) - enriched_hal_score %>% filter(distance == 0) %>% nrow()) *100, 0)`% du champ *title*, `r round(enriched_hal_score %>% distinct(hal_id, colHAL_jointure) %>% group_by(hal_id) %>% mutate(n=n()) %>% filter(n==1, colHAL_jointure == "booktitle") %>% distinct(hal_id) %>% nrow() / (n_distinct(enriched_hal_score$hal_id) - enriched_hal_score %>% filter(distance == 0) %>% nrow()) *100, 0)`% du champ *booktitle* et `r round(enriched_hal_score %>% distinct(hal_id, colHAL_jointure) %>% group_by(hal_id) %>% mutate(n=n()) %>% filter(n==2) %>% distinct(hal_id) %>% nrow() / (n_distinct(enriched_hal_score$hal_id) - enriched_hal_score %>% filter(distance == 0) %>% nrow()) *100, 0)`% des deux (la distance est la même pour ces 2 colonnes de jointure).

<br>

## Match par mot commun aux deux chaines de caractères (token) 

<br>

La deuxième jointure est réalisée en séparant tous les mots des intitulés d'articles et de conférences dans les données HAL, puis chacun d'eux est matché avec les acronymes des données CORE. Si un mot des intitulés HAL est **exactement le même** que l'acronyme CORE, alors l'entrée est enrichie du référentiel CORE. Ici encore, la manipulation est réalisée sur le champ *title*, puis sur le champ *booktitle* présents dans les données du HAL. 

De la même manière que le match par distance de chaînes de caractères, les intitulés et acronymes originaux sont réintégrés aux données finales. 

<br>

```{r}
# Match sur les tokens communs
    # colonne de jointure : TITLE
enriched_title_token <- hal_manip %>% 
    mutate(split = strsplit(as.character(hal_title), " ")) %>% unnest(split) %>% 
    filter(!is.na(split)) %>% 
    left_join(., 
              core_manip %>% select(core_title, core_acronym, Acronym, core_id, Source, Rank, `Primary FoR`), 
              by = c("split" = "core_acronym")) %>% 
    filter(!is.na(Acronym)) %>% 
    mutate(colHAL_jointure = "title")
    # colonne de jointure : BOOKTITLE
enriched_booktitle_token <- hal_manip %>% 
    mutate(split = strsplit(as.character(booktitle), " ")) %>% unnest(split) %>% 
    filter(!is.na(split)) %>% 
    left_join(., 
              core_manip %>% select(core_title, core_acronym, Acronym, core_id, Source, Rank, `Primary FoR`), 
              by = c("split" = "core_acronym")) %>% 
    filter(!is.na(Acronym)) %>% 
    mutate(colHAL_jointure = "booktitle")
    # on remet les 2 jointures ensemble
enriched_hal_token <- rbind(enriched_title_token, enriched_booktitle_token) %>% distinct() %>% 
    mutate(method = "token") %>% 
    select("hal_title","year","hal_id","booktitle", "split","core_title","Acronym","Source","Rank","Primary FoR","split","colHAL_jointure","method","core_id")

# On remet les noms initiaux (avec caractères spéciaux et majuscules)
enriched_hal_token <- enriched_hal_token %>% 
    # Noms des articles et conférences dans HAL
    select(-c(hal_title, booktitle)) %>% 
    left_join(., hal %>% select(title, booktitle, hal_id) %>% mutate(hal_id = str_replace_all(hal_id, "-", "")), by = "hal_id") %>% 
    rename(hal_title = title) %>% 
    # Noms des conférences et acronymes dans CORE
    select(-c(core_title)) %>% mutate(core_id = as.numeric(core_id)) %>% 
    left_join(., core %>% select(title, core_id), by = "core_id") %>% 
    rename(core_title = title) %>% 
    # Mise en forme finale
    select("hal_title","year","hal_id","booktitle","core_title","Acronym","Source","Rank","Primary FoR","colHAL_jointure","method")
```


```{r echo=FALSE, warning=FALSE, error=FALSE}
DT::datatable(enriched_hal_token, options=list(pageLength=25, searching=T, scrollX='400px'))
```


Cette deuxième passe de jointure exacte par mot commun à l'acronyme CORE, a permis d'enrichir `r n_distinct(enriched_hal_token$hal_id)` articles du HAL, dont `r length(setdiff(enriched_hal_token$hal_id, enriched_hal_score$hal_id))` qui n'avaient pas été enrichies par la première passe de match sur les chaînes de caractères.


<br>


```{r}
table <- enriched_hal_token %>% group_by(hal_id) %>% mutate(n=n())
hist(table$n, main = "Distribution du nombre d'acronymes matchés par article")
```



